#!/usr/bin/env bash

prompt=$(cat <<EOF
You are a helpful assistant.

EOF
) 


FIFO='/tmp/llm-response'
if ! [[ -e "$FIFO" ]]; then mkfifo "$FIFO"; fi
trap 'rm -f "$FIFO";exit 1' INT
trap 'rm -f "$FIFO";exit 0' EXIT

model="$BASHGPT_MODEL"
endpoint="$BASHGPT_ENDPOINT"
stream="true"
LOGGING='true'
LOGFILE="$HOME/.bashgpt.txt"

die() {
    echo "ERROR @ ${BASH_LINENO[1]}: $*" >&2; exit 1
}

log() {
    [[ ! "$LOGGING" ]] && return
    [[ "USER" == "$1" ]] || [[ "ASSISTANT" == "$1" ]] || die "log needs 'USER' or 'ASSISTANT'"
    [[ ! -e "$LOGFILE" ]] && touch "$LOGFILE"
    echo "$1" >> "$LOGFILE"
    shift
    echo "$*" >> "$LOGFILE"
    echo >> "$LOGFILE"
}

saniprint() {
    echo -ne "$*" \
        | sed -u \
        -e 's/^\"//' \
        -e 's/\"$//' \
        -e 's/\\\"/\"/g' \
        -e 's/[\*\`\>]//g'
}

trim_string() {
    # Usage: trim_string "   example   string    "
    : "${1#"${1%%[![:space:]]*}"}"
    : "${_%"${_##*[![:space:]]}"}"
    printf '%s\n' "$_"
}

parseLog() {
    [[ ! -e "$LOGFILE" ]] && echo '[]'; return
    local h=()
    local previous=''
    while read -r line; do
        if [[ "USER" == "$previous" ]]; then
            h+=("$(jq -n --arg l "$line" '{"role": "user", "content": $l}')")
        fi
        if [[ "ASSISTANT" == "$previous" ]]; then
            h+=("$(jq -n --arg l "$line" '{"role": "assistant", "content": $l}')")
        fi
        previous="$line"
    done < "$LOGFILE"

    echo "${h[*]}" | jq -s .
}

main() {
    local streamBuffer=''

    json=$(jq -n \
        --arg p "$prompt" \
        --arg q "$query" \
        --arg m "$model" \
        --argjson s "$stream" \
        '{
            "model": $m,
            "stream": $s,
            "messages": [
                {
                    "role": "system",
                    "content": $p
                },
                {
                    "role": "user",
                    "content": $q
                }
            ]
         }'
    )

    local log="$(parseLog)"
    # Kind of a hacky mess.
    json="$(jq -s \
        --argjson base "$json" \
        '
    . as $insert 
    | $base 
    | .messages |= (
        .[:1] + $insert[] + .[1:]
    )
    ' <<<"$log")"

    curl --silent "$endpoint" \
        -H 'Content-Type: application/json' \
        --data-binary @- <<<"$json" \
        > "$FIFO" &

    log "USER" "$query"
    while read -r line; do
        # remove 'data:' from beginning of each line.
        local l="$(sed -e 's/^data: //' <<< "$line")"
        if [[ "[DONE]" == "$l" ]]; then 
            break 
        fi

        local r="$(jq '.choices[0].delta.content' <<< "$l")"
        local rLog="$(jq -r '.choices[0].delta.content' <<< "$l")"
        if [[ "" != "$r" ]]; then 
            streamBuffer="$streamBuffer$rLog"
            saniprint "$r"
        fi
    done < "$FIFO"

    log "ASSISTANT" "${streamBuffer[*]}"
}

usage() {
    echo "use -p to set prompt"
}

while getopts ":p:lc" flag; do
    case "$flag" in
        p)
            prompt="$OPTARG"
            ;;
        l)
            LOGGING=''
            ;;
        c) # Clear chat history
            rm -f "$LOGFILE"
            exit
            ;;
        *) 
            echo "bad arg" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))
query="$*"

main
