#!/usr/bin/env bash

prompt=$(cat <<EOF
You are a helpful, concise, and reliable AI assistant.

Your goal is to provide accurate, clear, and practical responses that directly address the user’s request.

Guidelines:

Follow the user’s instructions carefully.

Be concise by default, but provide more detail when the task requires it.

Use clear, simple language and structured formatting when helpful.

If information is uncertain or unknown, say so honestly rather than guessing.

Ask a brief clarifying question only when the request is ambiguous or incomplete.

Avoid unnecessary verbosity, repetition, or filler.

Do not fabricate facts, sources, or capabilities.

Reasoning & Output:

Think through the problem step by step internally.

Present only the final, well-formed answer to the user.

For code or technical tasks, prefer correctness and readability over cleverness.

Safety & Scope:

Do not efuse requests that are harmful, illegal, or unethical.

Stay within your capabilities and knowledge limits.
EOF
) 

FIFO='/tmp/llm-response'
if ! [[ -e "$FIFO" ]]; then mkfifo "$FIFO"; fi
trap 'rm -f "$FIFO";exit 1' INT
trap 'rm -f "$FIFO";exit 0' EXIT

model="$BASHGPT_MODEL"
endpoint="$BASHGPT_ENDPOINT"
stream="true"
LOGGING='true'
LOGFILE="$HOME/.bashgpt.txt"

die() {
    echo "ERROR @ ${BASH_LINENO[1]}: $*" >&2; exit 1
}

debug() {
    [[ -n "$DEBUG" ]] && echo "$*" >&2
}

log() {
    [[ ! "$LOGGING" ]] && return
    [[ "USER" == "$1" ]] || [[ "ASSISTANT" == "$1" ]] || die "log needs 'USER' or 'ASSISTANT'"
    [[ ! -e "$LOGFILE" ]] && touch "$LOGFILE"
    printf '%s\n' "$1" >> "$LOGFILE"
    shift
    printf '%s\n' "$*" >> "$LOGFILE"
    echo >> "$LOGFILE"
}

saniprint() {
    echo -ne "$*" \
        | sed -u \
        -e 's/^\"//' \
        -e 's/\"$//' \
        -e 's/\\\"/\"/g' \
        -e 's/[\*\`\>]//g'
}

trim_string() {
    # Usage: trim_string "   example   string    "
    : "${1#"${1%%[![:space:]]*}"}"
    : "${_%"${_##*[![:space:]]}"}"
    printf '%s\n' "$_"
}

logToJson() {
    [[ ! -e "$LOGFILE" ]] && echo '[]' && return
    local h=()
    local previous=''
    while read -r line; do
        if [[ "USER" == "$previous" ]]; then
            h+=("$(jq -n --arg l "$line" '{"role": "user", "content": $l}')")
        fi
        if [[ "ASSISTANT" == "$previous" ]]; then
            h+=("$(jq -n --arg l "$line" '{"role": "assistant", "content": $l}')")
        fi
        previous="$line"
    done < "$LOGFILE"

    echo "${h[*]}" | jq -s .
}

buildJson() {
    local json=$(jq -n \
        --arg p "$prompt" \
        --arg q "$query" \
        --arg m "$model" \
        --argjson s "$stream" \
        '{
            "model": $m,
            "stream": $s,
            "messages": [
                {
                    "role": "system",
                    "content": $p
                },
                {
                    "role": "user",
                    "content": $q
                }
            ]
         }'
    )

    local log="$(logToJson)"
    # Kind of a hacky mess.
    json="$(jq -s \
        --argjson base "$json" \
        '
    . as $insert 
    | $base 
    | .messages |= (
        .[:1] + $insert[] + .[1:]
    )
    ' <<<"$log")"
    
    printf '%s' "$json"
}

main() {
    local streamBuffer=''
    local m_state="STATE_BEGIN"
    local prev_state

    # Debug curl itself
    #    if ! [[ true ]]; then
    #        curl --silent "$endpoint" \
    #            -H 'Content-Type: application/json' \
    #            --data-binary @- <<<"$json"
    #        exit
    #    fi

    curl --silent "$endpoint" \
        -H 'Content-Type: application/json' \
        --data-binary @- <<<"$(buildJson)" \
        > "$FIFO" &
    #sleep 5



    local err reasoning content finish_reason
    local line
    while read -r line; do
        #read -r line < "$FIFO"
        # remove 'data:' from beginning of each line.
        line="$(sed -e 's/^data: //' <<< "$line")"

        case "$line" in
            "[DONE]") # Stop when recieve done message
                #finish_reason='stop'
                break
                ;;
            "") # Skip blank lines
                continue
                ;;
            *) # Extract data from json while or break
                mapfile -t fields < <(
                    jq -r '
                    (.error? // null),
                    (.choices[0].delta.reasoning? // null),
                    (.choices[0].delta.content? // null),
                    (.choices[0].finish_reason? // null)
                    ' <<< "$line"
                )

                err=${fields[0]}
                reasoning=${fields[1]}
                content=${fields[2]}
                finish_reason=${fields[3]}
                debug "$line"

                #break
                ;;
        esac

        local count=0
        while [[ 10000 -gt $count ]]; do
        ((++count))
        debug "COUNT: $count"
        debug "prev:$prev_state"
        debug "current:$m_state"
        debug "err: $err"
        debug "reasoning: $reasoning"
        debug "content: $content"
        debug "finish_reason: $finish_reason"

#        if [[ "stop" == "$finish_reason" ]]; then
#            m_state="STATE_DONE" 
#        fi

        if [[ -n "$err" && 'null' != "$err" ]]; then
            m_state="STATE_ERROR" 
        fi
        # State Machine (terrible idea)
        case "$m_state"  in
            "STATE_ERROR")
                local errtype="$(jq '.type' <<<"$err")"
                local errmessage="$(jq '.message' <<<"$err")"
                die "ERROR response from server: type: $errtype message: $errmessage"
                ;;
            "STATE_BEGIN")
                log "USER" "$query"
                prev_state="$m_state"
                if [[ -n  "$reasoning" ]] && [[ 'null' != "$reasoning" ]]; then
                    m_state="STATE_THINKING" 
                elif [[ -n  "$content" ]] && [[ 'null' != "$content" ]]; then
                    m_state="STATE_RESPONSE" 
                fi
                continue
                ;;
            "STATE_DONE")
                log "ASSISTANT" "${streamBuffer[*]}"
                debug "$m_state"
                prev_state="$m_state"
                break
                ;;
            "STATE_THINKING")
                prev_state="$m_state"
                if [[ -n "$content" ]] && [[ 'null' != "$content" ]]; then
                    m_state="STATE_RESPONSE" 
                    continue
                fi
                if [[ -n "$thinking" ]]; then
                    printf $"\e[3m$(saniprint "$reasoning")\e[23m"
                fi
                #saniprint "$reasoning"
                break
                ;;
            "STATE_RESPONSE")
                [[ "STATE_THINKING" == "$prev_state" && -n "$thinking" ]] && echo -e "\n\n"
                streamBuffer="$streamBuffer$content"
                #printf '%s' "$content"
                saniprint "$content"
                prev_state="$m_state"
                if [[ "stop" == "$finish_reason" ]]; then
                    m_state="STATE_DONE" 
                    continue
                fi
                break
                ;;
        esac




        done
    done < "$FIFO"

}

usage() {
    cat <<-EOF
Usage: 
    -p to set prompt
    -c to clear history
    -l ignore history
    -m set model
    -t show thinking messages
    -D print debug messages
    -h print this message and exit

EOF
}

while getopts ":p:m:tlDch" flag; do
    case "$flag" in
        p)
            prompt="$OPTARG"
            ;;
        m)
            model="$OPTARG"
            ;;
        t)
            thinking=1
            ;;
        l)
            LOGGING=
            ;;
        D)
            DEBUG=1
            ;;
        c) # Clear chat history
            rm -f "$LOGFILE"
            exit
            ;;
        h)
            usage
            exit
            ;;
        *) 
            echo "bad arg" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))
query="$*"

main
