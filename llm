#!/usr/bin/env bash

prompt=$(cat <<EOF
You are a helpful, concise, and reliable AI assistant.

Your goal is to provide accurate, clear, and practical responses that directly address the user’s request.

Guidelines:

Follow the user’s instructions carefully.

Be concise by default, but provide more detail when the task requires it.

Use clear, simple language and structured formatting when helpful.

If information is uncertain or unknown, say so honestly rather than guessing.

Ask a brief clarifying question only when the request is ambiguous or incomplete.

Avoid unnecessary verbosity, repetition, or filler.

Do not fabricate facts, sources, or capabilities.

Reasoning & Output:

Think through the problem step by step internally.

Present only the final, well-formed answer to the user.

For code or technical tasks, prefer correctness and readability over cleverness.

Safety & Scope:

Do not efuse requests that are harmful, illegal, or unethical.

Stay within your capabilities and knowledge limits.
EOF
) 


FIFO='/tmp/llm-response'
if ! [[ -e "$FIFO" ]]; then mkfifo "$FIFO"; fi
trap 'rm -f "$FIFO";exit 1' INT
trap 'rm -f "$FIFO";exit 0' EXIT

model="$BASHGPT_MODEL"
endpoint="$BASHGPT_ENDPOINT"
stream="true"
LOGGING='true'
LOGFILE="$HOME/.bashgpt.txt"

die() {
    echo "ERROR @ ${BASH_LINENO[1]}: $*" >&2; exit 1
}

log() {
    [[ ! "$LOGGING" ]] && return
    [[ "USER" == "$1" ]] || [[ "ASSISTANT" == "$1" ]] || die "log needs 'USER' or 'ASSISTANT'"
    [[ ! -e "$LOGFILE" ]] && touch "$LOGFILE"
    echo "$1" >> "$LOGFILE"
    shift
    echo "$*" >> "$LOGFILE"
    echo >> "$LOGFILE"
}

saniprint() {
    echo -ne "$*" \
        | sed -u \
        -e 's/^\"//' \
        -e 's/\"$//' \
        -e 's/\\\"/\"/g' \
        -e 's/[\*\`\>]//g'
}

trim_string() {
    # Usage: trim_string "   example   string    "
    : "${1#"${1%%[![:space:]]*}"}"
    : "${_%"${_##*[![:space:]]}"}"
    printf '%s\n' "$_"
}

parseLog() {
    [[ ! -e "$LOGFILE" ]] && echo '[]' && return
    local h=()
    local previous=''
    while read -r line; do
        if [[ "USER" == "$previous" ]]; then
            h+=("$(jq -n --arg l "$line" '{"role": "user", "content": $l}')")
        fi
        if [[ "ASSISTANT" == "$previous" ]]; then
            h+=("$(jq -n --arg l "$line" '{"role": "assistant", "content": $l}')")
        fi
        previous="$line"
    done < "$LOGFILE"

    echo "${h[*]}" | jq -s .
}

main() {
    local streamBuffer=''

    json=$(jq -n \
        --arg p "$prompt" \
        --arg q "$query" \
        --arg m "$model" \
        --argjson s "$stream" \
        '{
            "model": $m,
            "stream": $s,
            "messages": [
                {
                    "role": "system",
                    "content": $p
                },
                {
                    "role": "user",
                    "content": $q
                }
            ]
         }'
    )

    local log="$(parseLog)"
    # Kind of a hacky mess.
    json="$(jq -s \
        --argjson base "$json" \
        '
    . as $insert 
    | $base 
    | .messages |= (
        .[:1] + $insert[] + .[1:]
    )
    ' <<<"$log")"

#    if [[ false ]]; then
#        curl --silent "$endpoint" \
#            -H 'Content-Type: application/json' \
#            --data-binary @- <<<"$json"
#        exit
#    fi

    curl --silent "$endpoint" \
        -H 'Content-Type: application/json' \
        --data-binary @- <<<"$json" \
        > "$FIFO" &

    log "USER" "$query"
    while read -r line; do
        # remove 'data:' from beginning of each line.
        local l="$(sed -e 's/^data: //' <<< "$line")"
        if [[ "[DONE]" == "$l" ]]; then 
            break 
        fi

        local r="$(jq '.choices[0].delta.content' <<< "$l")"
        local rLog="$(jq -r '.choices[0].delta.content' <<< "$l")"
        if [[ "" != "$r" ]]; then 
            streamBuffer="$streamBuffer$rLog"
            saniprint "$r"
        fi
    done < "$FIFO"

    log "ASSISTANT" "${streamBuffer[*]}"
}

usage() {
    echo "use -p to set prompt"
}

while getopts ":p:lc" flag; do
    case "$flag" in
        p)
            prompt="$OPTARG"
            ;;
        l)
            LOGGING=''
            ;;
        c) # Clear chat history
            rm -f "$LOGFILE"
            exit
            ;;
        *) 
            echo "bad arg" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))
query="$*"

main
